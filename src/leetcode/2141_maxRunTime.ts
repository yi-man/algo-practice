/**
 你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries ，其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟。你想使用这些电池让 全部 n 台电脑 同时 运行。

一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。

注意，你不能给电池充电。

请你返回你可以让 n 台电脑同时运行的 最长 分钟数。

## 问题分析步骤：

### 第一步：理解问题
- n 台电脑需要同时运行
- 每个电池有固定电量 batteries[i]
- 可以任意时刻切换电池（不花时间）
- 不能充电
- 求最长运行时间

### 第二步：关键观察
1. **总电量限制**：要让所有电脑运行 t 分钟，总需要 n * t 的电量
2. **单电池限制**：一个电池最多只能给一台电脑用，所以：
   - 如果 batteries[i] >= t，这个电池最多贡献 t 分钟（多余部分无法利用）
   - 如果 batteries[i] < t，这个电池贡献 batteries[i] 分钟
   - **为什么？** 因为一个电池同时只能给一台电脑供电。即使电池有 10 分钟电量，如果我们要让电脑运行 5 分钟，这个电池最多只能给一台电脑用 5 分钟，剩下的 5 分钟无法同时给另一台电脑用（因为需要同时运行）
3. **可行性判断**：对于给定的 t，如果 sum(min(batteries[i], t)) >= n * t，则可行
   - **为什么这个条件充分？** 因为我们可以任意切换电池，所以只要总可用电量 >= 总需要电量，就可以通过合理的分配让所有电脑同时运行 t 分钟

### 第三步：问题类型定位
这是一个 **二分查找 + 贪心验证** 的问题：
- **二分查找**：答案 t 的范围是 [0, sum(batteries) / n]
- **贪心验证**：对于每个候选 t，贪心地计算总可用电量

### 第四步：算法设计
1. 计算总电量和上界
2. 二分查找最大可行的 t
3. 对于每个 t，验证：sum(min(batteries[i], t)) >= n * t

### 第五步：优化
- 使用二分查找，时间复杂度 O(m * log(sum/n))，其中 m 是电池数量
- 空间复杂度 O(1)

### 第六步：示例验证
假设 n=2, batteries=[3,3,3]：
- 总电量 = 9，上界 = 9/2 = 4
- 二分查找过程：
  * t=2: min(3,2)+min(3,2)+min(3,2) = 6 >= 2*2=4 ✓ 可行
  * t=3: min(3,3)+min(3,3)+min(3,3) = 9 >= 2*3=6 ✓ 可行
  * t=4: min(3,4)+min(3,4)+min(3,4) = 9 >= 2*4=8 ✓ 可行
  * t=5: min(3,5)+min(3,5)+min(3,5) = 9 < 2*5=10 ✗ 不可行
- 答案：4

### 为什么贪心验证是正确的？
对于任意可行的 t，我们可以这样分配：
1. 将电池按电量排序
2. 对于电量 >= t 的电池，每个最多贡献 t 分钟
3. 对于电量 < t 的电池，贡献全部电量
4. 只要总贡献 >= n*t，就可以通过切换电池让所有电脑同时运行 t 分钟
 */
export function maxRunTime(n: number, batteries: number[]): number {
  // 计算总电量
  const totalPower = batteries.reduce((sum, battery) => sum + battery, 0);

  // 答案的上界：总电量 / 电脑数量（向下取整）
  let left = 0;
  let right = Math.floor(totalPower / n);

  // 二分查找最大可行的运行时间
  while (left < right) {
    // 注意：这里用 (left + right + 1) / 2 向上取整，避免死循环
    const mid = Math.floor((left + right + 1) / 2);

    // 验证 mid 分钟是否可行
    let availablePower = 0;
    for (const battery of batteries) {
      // 每个电池最多贡献 min(battery, mid) 分钟
      // 因为一个电池最多只能给一台电脑用 mid 分钟
      availablePower += Math.min(battery, mid);
    }

    // 如果可用电量 >= 需要的电量 (n * mid)，则可行
    if (availablePower >= n * mid) {
      left = mid; // 尝试更大的值
    } else {
      right = mid - 1; // 不可行，缩小上界
    }
  }

  return left;
}
